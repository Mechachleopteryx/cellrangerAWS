#! /bin/bash

set -o nounset -o pipefail -o errexit


# Inputs
INPUT="none"
S3="none"
CONFIG="none"
KEY="none"
FORCE_CLEAN=false


# Defaults
MANUAL_MODE=false
CLEAN_UP=false
TRANSFER_DATA=true
EC2_TYPE="c5.12xlarge"
AMI="ami-0c263cb10eeac51b6"
ZONE="us-west-2a"


# Usage message
usage() {
    echo """
USAGE
"$0" [OPTIONS]

OPTIONS
-h, display this message
-i, path to local directory containing fastq files, if this option is omitted files in the S3 bucket are used
-s, name of an S3 bucket
-c, path to config.yaml
-k, path to an ssh key linked to AWS account

-t, EC2 instance type (default is "$EC2_TYPE")
-a, ID for machine image configured to run cellranger (default is "$AMI")
-f, terminate running instances and start a new job
-m, run in manual mode, this transfers data to an EC2 instance and exits
    """
}





# Parse arguments =============================================================

while getopts ":hi:s:c:k:t:a:fm" args
do
    case "$args" in
        h)
            usage
            exit 0
            ;;
        i) INPUT="$OPTARG" ;;
        s) S3="s3://$OPTARG" ;;
        c) CONFIG="$OPTARG" ;;
        k) KEY="$OPTARG" ;;
        t) EC2_TYPE="$OPTARG" ;;
        a) AMI="$OPTARG" ;;
        f) CLEAN_UP=true ;;
        m) MANUAL_MODE=true ;;
        :)
            echo -e "\nERROR: -$OPTARG requires an argument"

            usage
            exit 1
            ;;
        *) 
            usage
            exit 1
            ;;
    esac
done

if [[ "$S3" == "none" || "$CONFIG" == "none" || "$KEY" == "none" ]]
then
    echo -e "\nERROR: Arguments are required for -s, -c, and -k."

    usage
    exit 1
fi

if [[ "$INPUT" == "none" ]]
then
    TRANSFER_DATA=false
fi





# Check instance/volume status =================================================

get_time() {
    echo "["$(date "+%F %T")"]"
}

check_status() {
    local input_fun="$1"
    local id="$2"
    local num=15
    local id_regex=$(echo $2 | sed 's/ /\|/g')

    if [[ "$#" == 3 ]]
    then
        local num="$3"
    fi

    for i in $(seq 1 "$num")
    do   
        sleep 20

        echo -e "\n$(get_time) Checking for $input_fun "$id"..."

        if "$input_fun" "$id" | grep -E --quiet "$id_regex"
        then
            return 0
        fi
    done

    echo -e "\n$(get_time) ERROR: Timed out waiting for $input_fun "$id"."

    exit 1
}

running_ec2() {
    aws ec2 describe-instances \
        --instance-ids $1 \
        --filters Name=instance-state-name,Values=running
}

terminated_ec2() {
    aws ec2 describe-instances \
        --instance-ids $1 \
        --filters Name=instance-state-name,Values=terminated
}





# Check for running EC2 instances ==============================================

check_for_ec2() {
    local running_ec2s=$(
        aws ec2 describe-instances \
            --filters Name=instance-state-name,Values=running
    )

    # Terminate EC2 instances from previous jobs
    if [[ "$running_ec2s" =~ "InstanceId" ]]
    then
        local ec2_ids=$(
            echo "$running_ec2s" \
	        | grep "InstanceId" \
                | grep -E -o "i\-[[:alnum:]]+"
        )

	if "$CLEAN_UP"
        then
            terminate_ec2 "$ec2_ids"
	
        elif "$FORCE_CLEAN"
        then
            echo -e "\n$(get_time) ERROR: EC2 instances from previous jobs are still running, to terminate these instances and start a new job include the -f option."

	    exit 1

	else
            echo -e "\n$(get_time) WARNING: EC2 instances from previous jobs are still running, to terminate these instances include the -f option."
        fi
    fi
}





# Transfer data to S3 bucket ===================================================

transfer_to_s3() {
    local input="$1"
    local s3="$2"

    local local_fqs=$(ls "$input/"*.fastq.gz)

    echo -e "\n$(get_time) Transferring the following files to S3 bucket $s3:"
    echo "$local_fqs"

    for fq in $local_fqs
    do
        aws s3 cp "$fq" "$s3" \
            > /dev/null
    done
}





# Launch EC2 instance ==========================================================
# When using default VPC the instance does not have internet access. To resolve
# this create new VPC, security group, subnet, and internet gateway. Activate
# public IP for subnet, activate public DNS for VPC, attach VPC to internet
# gateway, modify route table for VPC.

launch_ec2() {
    local s3="$1"
    local ami="$2"
    local ec2_type="$3"
    local zone="$4"
    local key_name=$(basename -s .pem "$KEY")

    echo -e "\n$(get_time) Launching EC2 $ec2_type instance..."

    # Get total size of fastqs in S3 bucket
    local data_size=$(
        aws s3 ls "$s3" --summarize --human-readable \
            | grep "Total Size" \
            | grep -E -o "[0-9].+$"
    )

    local vol_size=$(
        echo "$data_size" \
            | grep -E -o "^[0-9]+"
    )

    if [[ ! "$data_size" =~ [0-9\.]+.[G|T]iB ]]
    then
        local vol_size=10
    fi

    local vol_size=$(expr "$vol_size" \* 4 + 100)

    root_dev=$(
        aws ec2 describe-images \
            --image-id "$ami" \
            | grep -B 1 "Ebs" \
            | grep -E -o "/dev/[[:alnum:]]+"
    )

    # Launch EC2 instance
    # Public DNS is not listed in run-instances output, this must be retrieved
    # separately
    ec2_id=$(
        aws ec2 run-instances \
            --instance-type "$ec2_type" \
            --image-id "$ami" \
            --placement AvailabilityZone="$zone" \
            --block-device-mapping DeviceName="$root_dev",Ebs={VolumeSize="$vol_size"} \
            --key-name "$key_name" \
            | grep -E -o "InstanceId\": \"i\-[[:alnum:]]+" \
            | grep -E -o "i\-[[:alnum:]]+"
    )

    check_status running_ec2 "$ec2_id"

    echo -e "\n$(get_time) EC2 instance $ec2_id is running."
}





# Retrieve public DNS for EC2 instance and check connectivity ==================

get_dns() {
    local ec2="$1"

    # Retrieve public IP to check connectivity
    local ip=$(
        aws ec2 describe-instances \
            --instance-id "$ec2" \
            | grep -E "PublicIpAddress" \
            | grep -E -o "[0-9\.]+"
    )

    # Ping IP
    for i in $(seq 1 20)
    do
        echo -e "\n$(get_time) Pinging EC2 instance $ec2..."

        local packet_loss=$(
            ping -c 10 "$ip" \
                | grep -E -o "[0-9]+% packet loss" \
                | grep -E -o "[0-9]+"
        )

        # If IP responds to ping, return public DNS
        if [[ "$packet_loss" < 100 ]]
        then
            local dns=$(
                aws ec2 describe-instances \
                    --instance-id "$ec2" \
                    | grep -E -o "ec2\-[[:alnum:]\.\-]+compute.amazonaws.com" \
                    | head -n 1
            )

            EC2_SSH="ubuntu@$dns"

            sleep 10

            echo -e "\n$(get_time) EC2 instance $ec2 is online, use the following command to manually connect:"
            echo -e "ssh -i $KEY $EC2_SSH\n"

            return 0
        fi
    done

    # If IP does not respond to ping, terminate instance
    echo -e "\n$(get_time) ERROR: Unable to contact EC2 instance $ec2."

    terminate_ec2 "$ec2"

    exit 1
}





# Transfer data from S3 bucket to EBS volume ==================================

transfer_to_ec2() {
    local s3="$1"

    # Configure AWS on EC2 instance
    local iam_id=$(
        cat "$HOME/.aws/credentials" \
            | grep -A 2 "default" \
            | grep "aws_access_key_id" \
            | grep -E -o "[[:alnum:]]+$"
    )

    local iam_key=$(
        cat "$HOME/.aws/credentials" \
            | grep -A 2 "default" \
            | grep "aws_secret_access_key" \
            | grep -E -o "[[:alnum:]/\+]+$"
    )

    local aws="/usr/local/bin/aws"

    ssh -o "StrictHostKeyChecking no" -i "$KEY" "$EC2_SSH" \
        "$aws" configure set aws_access_key_id "$iam_id"

    ssh -i "$KEY" "$EC2_SSH" \
        "$aws" configure set aws_secret_access_key "$iam_key"

    # Transfer files to EC2 instance
    local s3_fqs=$(
        aws s3 ls "$s3" \
            | grep -E -o "[[:alnum:]_\-\.]+.fastq.gz"
    )

    echo -e "\n$(get_time) Transferring the following files from $s3 to EC2 instance:"
    echo "$s3_fqs"

    scp -i "$KEY" "$CONFIG" "$EC2_SSH:~/PIPELINE" \
        > /dev/null

    # Leave s3_fqs unquoted
    for fq in $s3_fqs
    do 
        ssh -i "$KEY" "$EC2_SSH" \
            "$aws" s3 cp "$s3/$fq" "~/DATA" \
            > /dev/null
    done
   
    wait

    sleep 30
}





# Run Cell Ranger ==============================================================

run_cellranger() {
    local s3="$1"

    aws="/usr/local/bin/aws"

    echo -e "\n$(get_time) Beginning Cell Ranger run..."

    ssh -i "$KEY" "$EC2_SSH" \
        bash "~/PIPELINE/snakecharmer.sh"

    echo -e "\n$(get_time) Cell Ranger run has completed, transferring results to S3 bucket $s3."
    
    ssh -i "$KEY" "$EC2_SSH" \
        "$aws" s3 cp --recursive "~/RESULTS" "$s3/RESULTS"

    ssh -i "$KEY" "$EC2_SSH" \
        "$aws" s3 cp --recursive "~/PIPELINE" "$s3/PIPELINE"
}





# Terminate EC2 instance =======================================================

terminate_ec2() {
    local ec2="$1"

    echo -e "\n$(get_time) Terminating EC2 instances "$ec2"..."

    aws ec2 terminate-instances \
        --instance-ids $ec2 \
        > /dev/null

    check_status terminated_ec2 "$ec2" 
	
    # Keep this quoting pattern so multiple IDs are displayed on one line
    echo -e "\n$(get_time) EC2 instances "$ec2" have been terminated."
}





# Main =========================================================================

main() {
    # Terminate instances from previous runs
    check_for_ec2

    # Transfer data to S3 bucket
    if "$TRANSFER_DATA"
    then
        transfer_to_s3 \
            "$INPUT" \
            "$S3"
    fi

    # Launch EC2 instance and retrieve ec2_id
    launch_ec2 \
        "$S3" \
        "$AMI" \
        "$EC2_TYPE" \
        "$ZONE"

    # Check EC2 instance connectivity and retrieve EC2_SSH
    get_dns "$ec2_id"

    # Transfer data from S3 bucket to EC2 instance
    transfer_to_ec2 "$S3" 

    if "$MANUAL_MODE"
    then
        exit 0
    fi

    # Run Cell Ranger
    run_cellranger "$S3"

    # Terminate EC2 instance
    terminate_ec2 "$ec2_id"
}

main





