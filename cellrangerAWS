#! /bin/bash

set -o nounset -o pipefail


# Inputs
PROJECT="cellranger"
INPUT="none"
OUTPUT="none"
KEY="none"

EC2_ID="none"
EC2_TYPE="t2.2xlarge"
AMI="ami-0f045956ed47d262b"
CREATE_VOL=true
VOLUME_SIZE=50

ZONE="us-west-2a"
SECURITY_GROUP="sg-00cf9318d9719735d"
SUBNET="subnet-083a3a855e543ee1c"
EC2_USER="ubuntu"



# Usage message
usage() {
    echo """
USAGE
"$0" [OPTIONS]

OPTIONS
-h, display this message
-i, path to input directory containing fastq files and config.yaml or ID for snapshot containing data
-o, path to output directory
-k, path to AWS private key
-p, project name (default is \"cellranger\")
-e, ID for EC2 instance with an EBS volume already mounted, by default a new instance is created
-t, EC2 instance type (default is "$EC2_TYPE")
-s, size of EBS volume in GiB, by default this is set based on the size of the fastqs present in the input directory
-a, ID for machine image configured to run cellranger (default is "$AMI")

    """
}



# Parse arguments
while getopts ":hi:o:k:p:e:t:s:a:" args
do
    case "$args" in
        help)
            usage
            exit 0
            ;;
        i) 
            INPUT="$OPTARG"

	    if [[ "$INPUT" =~ ^snap\-[[:alnum:]]+$ ]]
            then
                CREATE_VOL=false
            fi
            ;;
        o)
            OUTPUT="$OPTARG"
            ;;
        k)
            KEY="$OPTARG"
            ;;
        p)
            PROJECT="$OPTARG"
            ;;
        e)
            EC2_ID="$OPTARG"
            ;;
        t)
            EC2_TYPE="$OPTARG"
            ;;
        s)
            VOLUME_SIZE="$OPTARG"
            ;;
        a)
            AMI="$OPTARG"
            ;;
        :)
            echo -e "\nERROR: -$OPTARG requires an argument"

            usage
	    exit 1
            ;;
	*) 
            usage
	    exit 1
            ;;
    esac
done

if [[ "$INPUT" == "none" || "$OUTPUT" == "none" || "$KEY" == "none" ]]
then
    echo -e "\nERROR: Arguments are required for -i, -o, and -k."

    usage
    exit 1
fi



# Check instance/volume status
check_status() {
    local input_fun=$1
    local id=$2

    echo -e "\nChecking for $input_fun $id...\n"


    for i in $(seq 1 60)
    do
        if "$input_fun" "$id" | grep --quiet "$id"
        then
            return 0
        fi

        sleep 5
    done

    echo -e "\nERROR: Timed out waiting for $input_fun $id.\n"

    exit 1
}



# Launch EC2 instance
# When using default VPC the instance does not have internet access. To resolve
# this create new VPC, security group, subnet, and internet gateway. Activate
# public IP for subnet, activate public DNS for VPC, attach VPC to internet
# gateway, modify route table for VPC.
launch_ec2() {
    local ami="$1"
    local ec2_type="$2"
    local zone="$3"
    local security_group="$4"
    local subnet="$5"
    local key_name=$(basename -s .pem "$KEY")

    echo -e "\nLaunching EC2 $EC2_TYPE instance..."


    # Launch EC2 instance
    # Public DNS is not listed in run-instances output, this must be retrieved separately
    ec2_id=$(
        aws ec2 run-instances \
            --instance-type "$ec2_type" \
            --image-id "$ami" \
            --placement AvailabilityZone="$zone" \
            --security-group-ids "$security_group" \
            --subnet-id "$subnet" \
            --key-name "$key_name" \
            --associate-public-ip-address \
            | grep -E -o "InstanceId\": \"i\-[[:alnum:]]+" \
            | grep -E -o "i\-[[:alnum:]]+"
    )

    running_ec2() {
        aws ec2 describe-instances \
            --instance-id "$1" \
            --filters Name=instance-state-name,Values=running
    }

    check_status running_ec2 "$ec2_id"

    echo -e "\nEC2 instance $ec2_id has been successfully launched."
}



# Retrieve public DNS for EC2 instance and check connectivity
get_dns() {
    local ec2="$1"

    echo -e "\nAttempting to make contact with EC2 instance $ec2...\n"


    # Retrieve public IP to check connectivity
    local ip=$(
        aws ec2 describe-instances \
            --instance-id "$ec2" \
            | grep -E "PublicIpAddress" \
            | grep -E -o "[0-9\.]+"
    )



    # Ping IP
    for i in $(seq 1 20)
    do
        local packet_loss=$(
            ping -c 10 "$ip" \
                | grep -E -o "[0-9]+% packet loss" \
                | grep -E -o "[0-9]+"
        )

        # If IP responds to ping, return public DNS
        if [[ "$packet_loss" < 100 ]]
        then
            local dns=$(
                aws ec2 describe-instances \
                    --instance-id "$ec2" \
                    | grep -E -o "ec2\-[[:alnum:]\.\-]+compute.amazonaws.com" \
                    | head -n 1
            )

            ec2_ssh="$EC2_USER@$dns"

            echo -e """
Connection has been established with EC2 instance $ec2.

Use the following command to manually connect to the instance:
ssh -i "$KEY" "$ec2_ssh"
            """

            return 0
        fi
    done



    # If IP does not respond to ping, terminate instance
    aws ec2 terminate-instances \
        --instance-ids "$ec2"

    echo -e "\nERROR: Unable to connect, terminating EC2 instance $ec2...\n"

    exit 1
}


    
# Create and mount EBS volume on EC2 instance
create_ebs() {
    local input=$1
    local ec2=$2
    local vol_size=$3
    local zone=$4
    local ssh=$5

    echo -e "\nCreating EBS volume...\n"


    # Get list of attached devices, need this to identify attached EBS volume
    local old_devs=$(
        ssh -o "StrictHostKeyChecking no" -i "$KEY" "$ssh" \
            sudo fdisk -l \
                | grep -E -o "/dev/[[:alnum:]]+" \
                2>&1
    )

    # Keep old_devs unquoted here
    local old_devs=$(
        echo $old_devs \
            | sed 's/ /|/g'
    )



    # Create EBS volume
    if "$CREATE_VOL"
    then
        vol_id=$(
            aws ec2 create-volume \
                --size "$vol_size" \
                --availability-zone "$zone" \
                | grep -E -o "vol\-[[:alnum:]]+"
        )

        local vol_msg="\nEBS volume $vol_id ($vol_size GiB) was created and mounted to EC2 instance $ec2.\n"

    else
        vol_id=$(
            aws ec2 create-volume \
                --snapshot-id "$INPUT" \
                --availability-zone "$zone" \
	        | grep -E -o "vol\-[[:alnum:]]+"
        )

        local vol_msg="\nEBS volume $vol_id was created from snapshot $INPUT and mounted to EC2 instance $ec2.\n"
    fi

    available_vol() {
        aws ec2 describe-volumes \
            --volume-ids "$1" \
            --filters Name=status,Values=available
    }

    check_status available_vol "$vol_id"



    # Attach EBS volume
    aws ec2 attach-volume \
        --instance-id "$ec2" \
        --volume-id "$vol_id" \
        --device /dev/sdh \
        > /dev/null

    attached_vol() {
        aws ec2 describe-volumes \
            --volume-ids "$1" \
            --filters Name=attachment.status,Values=attached
    }

    check_status attached_vol "$vol_id"



    # Identify device path for EBS volume
    local new_devs=$(
        ssh -i "$KEY" "$ssh" \
            sudo fdisk -l \
                | grep -E "^Disk .+$vol_size GiB" \
                | grep -E -o "/dev/[[:alnum:]]+" \
                2>&1
    )
    
    local dev_path=$(
        echo "$new_devs" \
            | grep -E -v "$old_devs"
    )



    # Format new EBS volume
    if "$CREATE_VOL"
    then
        ssh -i "$KEY" "$ssh" bash <<EOF
            sudo parted "$dev_path" mklabel gpt > /dev/null 2>&1
	    sudo parted -a opt "$dev_path" mkpart primary ext4 0% 100% > /dev/null 2>&1
	    sudo mkfs.ext4 -F "$dev_path" > /dev/null 2>&1
EOF

    fi



    # Mount EBS volume
    ssh -i "$KEY" "$ssh" bash <<EOF
        sudo mkdir -p /mnt/EBS
        sudo mount "$dev_path" /mnt/EBS
        sudo mkdir -p /mnt/EBS/DATA
        sudo chmod -R 777 /mnt/EBS
EOF

    echo -e "$vol_msg"
}



# Transfer data to mounted EBS volume
transfer_data() {
    local input="$1"
    local vol="$2"
    local ssh="$3"
    local snap_name="$4"
    local snap_id="$1"

    
    if "$CREATE_VOL"
    then
	echo -e "\nTransferring data to EBS volume $vol...\n"

        scp -i "$KEY" "$input"/*.fastq.gz "$ssh":/mnt/EBS/DATA
        scp -i "$KEY" "$input"/config.yaml "$ssh":/mnt/EBS/DATA

        # Save snapshot of EBS volume
        snap_id=$(
            aws ec2 create-snapshot \
                --description "$snap_name" \
                --volume-id "$vol" \
	        | grep -E -o "snap\-[[:alnum:]]+"
    	)

	echo -e "\nEBS volume $vol has been saved to snapshot $snap_id.\n"
    fi
}



# Terminate EC2 instance, create snapshot to save data, delete EBS volume
terminate_ec2() {
    local ec2="$1"
    local vol="$2"
    local snap="$3"


    # Make sure snapshot has been saved before terminating EC2 instance
    completed_snap() {
        aws ec2 describe-snapshots \
            --snapshot-ids "$1" \
            --filters Name=status,Values=completed
    }

    check_status completed_snap "$snap"



    # Terminate EC2 instance
    echo -e "\nTerminating EC2 instance "$ec2"\n"

    aws ec2 terminate-instances \
        --instance-ids "$ec2"

    terminated_ec2() {
        aws ec2 describe-instances \
            --instance-id "$1" \
            --filters Name=instance-state-name,Values=terminated
    }

    check_status terminated_ec2 "$ec2"



    # Delete EBS volume
    echo -e "\nDeleting EBS volume $vol...\n"

    aws ec2 delete-volume \
        --volume-id "$vol"

    echo """

EC2 instance $ec2_id has been terminated and EBS volume $vol_id has been deleted.

Fastqs have been saved to snapshot $snap.

Samples can be re-run using the following command:
$0 -i $snap_id -o $OUTPUT -k $KEY

    """
}



# Main function
main() {
  

    # Set project name
    project_name="$PROJECT"_$(date +%Y%m%d-%H%M%S)



    # Calculate EBS volume size
    data_size=$(
        du -shc -BG "$INPUT" \
            | grep "total" \
            | grep -E -o "[0-9]+"
    )

    volume_size=$(expr "$data_size" \* 2)

    if [[ "$VOLUME_SIZE" > "$volume_size" ]]
    then
        volume_size="$VOLUME_SIZE"
    fi



    # Launch EC2 instance and retrieve ec2_id
    ec2_id="$EC2_ID"

    if [[ "$EC2_ID" == "none" ]]
    then
        launch_ec2 \
            "$AMI" \
            "$EC2_TYPE" \
            "$ZONE" \
            "$SECURITY_GROUP" \
            "$SUBNET"
    fi



    # Check EC2 instance connectivity and retrieve ec2_ssh
    get_dns "$ec2_id"



    # Create EBS volume and transfer data
    if [[ "$EC2_ID" == "none" ]]
    then
        # Create EBS volume and retrieve vol_id
        create_ebs \
            "$INPUT" \
            "$ec2_id" \
            "$volume_size" \
            "$ZONE" \
            "$ec2_ssh"

        # Transfer data to EBS volume and retrieve snap_id
        transfer_data \
            "$INPUT" \
            "$vol_id" \
            "$ec2_ssh" \
            "$project_name"
    fi



    # Run cellranger and transfer results
    echo -e "\nBeginning cellranger run...\n"

    ssh -i "$KEY" "$ec2_ssh" \
        bash "/home/$EC2_USER/PIPELINE/snakecharmer.sh"

    echo -e "Cellranger run has completed, transferring results to $OUTPUT.\n"

    rsync -r -e "ssh -i $KEY" --exclude possorted_genome_bam.bam* \
        "$ec2_ssh:/mnt/EBS/RESULTS/"* "$OUTPUT"



    # Terminate EC2 instance
    if [[ "$EC2_ID" == "none" ]]
    then
        terminate_ec2 \
            "$ec2_id" \
            "$vol_id" \
            "$snap_id"
    fi
}



main



